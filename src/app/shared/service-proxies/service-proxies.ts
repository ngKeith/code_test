//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Test to see if the gateway router is live
     * @return Successful Hello response
     */
    postStatus(body: BodyCheck): Observable<StatusCheck> {
        let url_ = this.baseUrl + "/post-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusCheck>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusCheck>;
        }));
    }

    protected processPostStatus(response: HttpResponseBase): Observable<StatusCheck> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusCheck.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusCheck>(null as any);
    }

    /**
     * login to the backend gateway using form data
     * @return successfully logged in
     */
    tokenCookie(body: Body_route_login_access_token_token_cookie_post): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/token-cookie";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTokenCookie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTokenCookie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processTokenCookie(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponse>(null as any);
    }

    /**
     * login to the backend gateway using form data
     * @return successfully logged in
     */
    token(body: Body_bearer_token_access_token_post): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processToken(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponse>(null as any);
    }

    /**
     * Homepage
     * @return Successful Response
     */
    index(): Observable<any> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * Test to see if the gateway router is live
     * @return Successful Hello response
     */
    status(): Observable<StatusCheck> {
        let url_ = this.baseUrl + "/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusCheck>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusCheck>;
        }));
    }

    protected processStatus(response: HttpResponseBase): Observable<StatusCheck> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusCheck.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusCheck>(null as any);
    }

    /**
     * perform basic authentication to login to backend gateway
     * @param type (optional) 
     * @param reset (optional) 
     * @return Successfully logged in
     */
    admin_tools(type: string | undefined, reset: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/admin_tools/?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (reset === null)
            throw new Error("The parameter 'reset' cannot be null.");
        else if (reset !== undefined)
            url_ += "reset=" + encodeURIComponent("" + reset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdmin_tools(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdmin_tools(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAdmin_tools(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * get the open api schema
     * @return Successfully retrieved open api spec
     */
    openapi_json(): Observable<any> {
        let url_ = this.baseUrl + "/openapi.json";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenapi_json(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenapi_json(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processOpenapi_json(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * nswag endpoint to refresh frontend proxies
     * @return Successfully retreived backend endpoints
     */
    nswag(serverKey: string): Observable<any> {
        let url_ = this.baseUrl + "/nswag/{serverKey}";
        if (serverKey === undefined || serverKey === null)
            throw new Error("The parameter 'serverKey' must be defined.");
        url_ = url_.replace("{serverKey}", encodeURIComponent("" + serverKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNswag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNswag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processNswag(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * get the swagger ui
     * @return successfully opened swagger ui
     */
    docs(): Observable<any> {
        let url_ = this.baseUrl + "/docs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDocs(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * get the redoc swagger ui
     * @return successfully opened redoc swagger ui
     */
    redoc(): Observable<any> {
        let url_ = this.baseUrl + "/redoc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRedoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRedoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processRedoc(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }
}

@Injectable()
export class AdminServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * register users or admins
     * @return successful registration
     */
    register(body: RegisterUser): Observable<UserDetailsResponse> {
        let url_ = this.baseUrl + "/admin/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetailsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetailsResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<UserDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsResponse>(null as any);
    }

    /**
     * takes in a csv or xlsx file and bulk adds users of various types to DB
     * @return Successful Response
     */
    bulkRegister(body: Blob): Observable<BulkUserInsertionResponse> {
        let url_ = this.baseUrl + "/admin/bulk-register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "multipart/form-data",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkUserInsertionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkUserInsertionResponse>;
        }));
    }

    protected processBulkRegister(response: HttpResponseBase): Observable<BulkUserInsertionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkUserInsertionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BulkUserInsertionResponse>(null as any);
    }

    /**
     * fetch admins
     * @return successfully fetched admins
     */
    getAdmins(): Observable<AdminDetailsManyResponse> {
        let url_ = this.baseUrl + "/admin/get-admins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdmins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdmins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDetailsManyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDetailsManyResponse>;
        }));
    }

    protected processGetAdmins(response: HttpResponseBase): Observable<AdminDetailsManyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDetailsManyResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDetailsManyResponse>(null as any);
    }

    /**
     * fetch lodge admins form from db
     * @return successfully fetched lodge admins
     */
    getAdminDetails(adminId: string): Observable<AdminDetailsResponse> {
        let url_ = this.baseUrl + "/admin/get-admin-details/{adminId}";
        if (adminId === undefined || adminId === null)
            throw new Error("The parameter 'adminId' must be defined.");
        url_ = url_.replace("{adminId}", encodeURIComponent("" + adminId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDetailsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDetailsResponse>;
        }));
    }

    protected processGetAdminDetails(response: HttpResponseBase): Observable<AdminDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdminDetailsResponse>(null as any);
    }

    /**
     * fetch users from server
     * @return successfully fetched users
     */
    getUsers(): Observable<UserDetailsManyResponse> {
        let url_ = this.baseUrl + "/admin/get-users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetailsManyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetailsManyResponse>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserDetailsManyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailsManyResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsManyResponse>(null as any);
    }

    /**
     * fetch user details from server
     * @return successfully fetched user details
     */
    getUserDetails(userId: string): Observable<UserDetailsResponse> {
        let url_ = this.baseUrl + "/admin/get-user-details/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetailsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetailsResponse>;
        }));
    }

    protected processGetUserDetails(response: HttpResponseBase): Observable<UserDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsResponse>(null as any);
    }

    /**
     * get permissions
     * @return successful permissions retrieval
     */
    getPermissions(app: string): Observable<PermissionsResponse> {
        let url_ = this.baseUrl + "/admin/get-permissions/{app}";
        if (app === undefined || app === null)
            throw new Error("The parameter 'app' must be defined.");
        url_ = url_.replace("{app}", encodeURIComponent("" + app));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionsResponse>;
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionsResponse>(null as any);
    }
}

@Injectable()
export class SecurityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * verify JWT and DB Token
     * @return successfully verified
     */
    register(body: AppRegister): Observable<BasicResponse> {
        let url_ = this.baseUrl + "/security/register/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasicResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasicResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<BasicResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasicResponse>(null as any);
    }

    /**
     * verify JWT and DB Token
     * @return successfully verified
     */
    checkRecaptcha(body: AppRecaptcha): Observable<BasicResponse> {
        let url_ = this.baseUrl + "/security/check-recaptcha/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRecaptcha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRecaptcha(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasicResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasicResponse>;
        }));
    }

    protected processCheckRecaptcha(response: HttpResponseBase): Observable<BasicResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasicResponse>(null as any);
    }

    /**
     * user login attempt
     * @return successful login
     */
    login(body: Login): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/security/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponse>(null as any);
    }

    /**
     * attempt to set password for given account with otp
     * @return successfully set password
     */
    setPassword(body: Login): Observable<BasicResponse> {
        let url_ = this.baseUrl + "/security/set-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasicResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasicResponse>;
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<BasicResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasicResponse>(null as any);
    }

    /**
     * get current user from token
     * @return successfully retreived user
     */
    mongoLogin(body: Login): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/security/mongo-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMongoLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMongoLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processMongoLogin(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponse>(null as any);
    }

    /**
     * verify JWT and DB Token
     * @return successfully verified
     */
    verify(): Observable<VerifyResponse> {
        let url_ = this.baseUrl + "/security/verify";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerifyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerifyResponse>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<VerifyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerifyResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VerifyResponse>(null as any);
    }

    /**
     * create OTP code
     * @return successfully created code
     */
    createCode(body: CreateCode): Observable<BasicResponse> {
        let url_ = this.baseUrl + "/security/create-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasicResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasicResponse>;
        }));
    }

    protected processCreateCode(response: HttpResponseBase): Observable<BasicResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasicResponse>(null as any);
    }

    /**
     * verify public token
     * @return successfully verified token
     */
    verifyPublicToken(): Observable<TokenResponse> {
        let url_ = this.baseUrl + "/security/verify-public-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyPublicToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyPublicToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResponse>;
        }));
    }

    protected processVerifyPublicToken(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenResponse>(null as any);
    }

    /**
     * verify admin token
     * @return successfully verified token
     */
    verifyAdminToken(): Observable<TokenResponse> {
        let url_ = this.baseUrl + "/security/verify-admin-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyAdminToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyAdminToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenResponse>;
        }));
    }

    protected processVerifyAdminToken(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenResponse>(null as any);
    }

    /**
     * get current user from token
     * @return successfully retreived user
     */
    getCurrentUser(): Observable<BasicResponse> {
        let url_ = this.baseUrl + "/security/get-current-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasicResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasicResponse>;
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<BasicResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasicResponse>(null as any);
    }
}

@Injectable()
export class PublicServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * get a user
     * @return successful user retrieval
     */
    getUserDetails(): Observable<UserDetailsResponse> {
        let url_ = this.baseUrl + "/public/get-user-details";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDetailsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDetailsResponse>;
        }));
    }

    protected processGetUserDetails(response: HttpResponseBase): Observable<UserDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsResponse>(null as any);
    }
}

@Injectable()
export class QrServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Generate QR code details and send user SMS for QR code
     * @return Successfully generated a qr code and sent user SMS
     */
    addCode(body: NewQuote): Observable<QRUserDataResponse> {
        let url_ = this.baseUrl + "/qr/add-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QRUserDataResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QRUserDataResponse>;
        }));
    }

    protected processAddCode(response: HttpResponseBase): Observable<QRUserDataResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QRUserDataResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QRUserDataResponse>(null as any);
    }

    /**
     * Loads specific users verification page/updates state with details and alerts user their qr code has been scanned
     * @return Successfully scanned users qr code and retrieved details/notified user
     */
    getVerificationDetails(uuid: string): Observable<QRUserDataResponse> {
        let url_ = this.baseUrl + "/qr/get-verification-details/{uuid}";
        if (uuid === undefined || uuid === null)
            throw new Error("The parameter 'uuid' must be defined.");
        url_ = url_.replace("{uuid}", encodeURIComponent("" + uuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVerificationDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerificationDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QRUserDataResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QRUserDataResponse>;
        }));
    }

    protected processGetVerificationDetails(response: HttpResponseBase): Observable<QRUserDataResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QRUserDataResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QRUserDataResponse>(null as any);
    }

    /**
     * Use the QR code (validates and consumes code)
     * @return Successfully used the QR code
     */
    verifyQrCode(uuid: string): Observable<BasicResponse> {
        let url_ = this.baseUrl + "/qr/verify-qr-code/{uuid}";
        if (uuid === undefined || uuid === null)
            throw new Error("The parameter 'uuid' must be defined.");
        url_ = url_.replace("{uuid}", encodeURIComponent("" + uuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyQrCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyQrCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasicResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasicResponse>;
        }));
    }

    protected processVerifyQrCode(response: HttpResponseBase): Observable<BasicResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasicResponse>(null as any);
    }

    /**
     * get all agents codes generated and related quote refs
     * @return Successfully got all agents codes generated and related quote refs
     */
    getAgentQuotes(agent_id: string): Observable<AgentQuotesResponse> {
        let url_ = this.baseUrl + "/qr/get-agent-quotes/{agent_id}";
        if (agent_id === undefined || agent_id === null)
            throw new Error("The parameter 'agent_id' must be defined.");
        url_ = url_.replace("{agent_id}", encodeURIComponent("" + agent_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgentQuotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgentQuotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgentQuotesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgentQuotesResponse>;
        }));
    }

    protected processGetAgentQuotes(response: HttpResponseBase): Observable<AgentQuotesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgentQuotesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgentQuotesResponse>(null as any);
    }

    /**
     * store sms results
     * @param api_key (optional) 
     * @return succesfully stored sms results
     */
    smsSuccess(api_key: string | undefined, body: SMSSuccessBody): Observable<SMSSuccessResponse> {
        let url_ = this.baseUrl + "/qr/sms-success";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "api-key": api_key !== undefined && api_key !== null ? "" + api_key : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSmsSuccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSmsSuccess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SMSSuccessResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SMSSuccessResponse>;
        }));
    }

    protected processSmsSuccess(response: HttpResponseBase): Observable<SMSSuccessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SMSSuccessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SMSSuccessResponse>(null as any);
    }
}

export class AdminDetails implements IAdminDetails {
    _id!: string;
    firstName!: string;
    lastName!: string;
    email!: string;
    mobile!: string;
    createdAt!: number;
    updatedAt!: number;
    active!: boolean;

    [key: string]: any;

    constructor(data?: IAdminDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.firstName = "";
            this.lastName = "";
            this.email = "";
            this.mobile = "";
            this.createdAt = 0;
            this.updatedAt = 0;
            this.active = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this._id = _data["_id"];
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : "";
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : "";
            this.email = _data["email"] !== undefined ? _data["email"] : "";
            this.mobile = _data["mobile"] !== undefined ? _data["mobile"] : "";
            this.createdAt = _data["createdAt"] !== undefined ? _data["createdAt"] : 0;
            this.updatedAt = _data["updatedAt"] !== undefined ? _data["updatedAt"] : 0;
            this.active = _data["active"] !== undefined ? _data["active"] : false;
        }
    }

    static fromJS(data: any): AdminDetails {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["_id"] = this._id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        data["active"] = this.active;
        return data;
    }
}

export interface IAdminDetails {
    _id: string;
    firstName: string;
    lastName: string;
    email: string;
    mobile: string;
    createdAt: number;
    updatedAt: number;
    active: boolean;

    [key: string]: any;
}

export class AdminDetailsManyResponse implements IAdminDetailsManyResponse {
    code!: number;
    admins!: AdminDetails[];

    [key: string]: any;

    constructor(data?: IAdminDetailsManyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.admins = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            if (Array.isArray(_data["admins"])) {
                this.admins = [] as any;
                for (let item of _data["admins"])
                    this.admins!.push(AdminDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminDetailsManyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDetailsManyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        if (Array.isArray(this.admins)) {
            data["admins"] = [];
            for (let item of this.admins)
                data["admins"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAdminDetailsManyResponse {
    code: number;
    admins: AdminDetails[];

    [key: string]: any;
}

export class AdminDetailsResponse implements IAdminDetailsResponse {
    code!: number;
    details!: AdminDetails;

    [key: string]: any;

    constructor(data?: IAdminDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.details = _data["details"] ? AdminDetails.fromJS(_data["details"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdminDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAdminDetailsResponse {
    code: number;
    details: AdminDetails;

    [key: string]: any;
}

export class AgentQuotesResponse implements IAgentQuotesResponse {
    code!: number;
    quotes!: QuoteDetails[];

    [key: string]: any;

    constructor(data?: IAgentQuotesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.quotes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            if (Array.isArray(_data["quotes"])) {
                this.quotes = [] as any;
                for (let item of _data["quotes"])
                    this.quotes!.push(QuoteDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgentQuotesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AgentQuotesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        if (Array.isArray(this.quotes)) {
            data["quotes"] = [];
            for (let item of this.quotes)
                data["quotes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgentQuotesResponse {
    code: number;
    quotes: QuoteDetails[];

    [key: string]: any;
}

export class AppRecaptcha implements IAppRecaptcha {
    recaptchaToken!: string;

    [key: string]: any;

    constructor(data?: IAppRecaptcha) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.recaptchaToken = _data["recaptchaToken"];
        }
    }

    static fromJS(data: any): AppRecaptcha {
        data = typeof data === 'object' ? data : {};
        let result = new AppRecaptcha();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["recaptchaToken"] = this.recaptchaToken;
        return data;
    }
}

export interface IAppRecaptcha {
    recaptchaToken: string;

    [key: string]: any;
}

export class AppRegister implements IAppRegister {
    appId!: string;
    appKey!: string;
    recaptchaToken!: string;

    [key: string]: any;

    constructor(data?: IAppRegister) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.appId = _data["appId"];
            this.appKey = _data["appKey"];
            this.recaptchaToken = _data["recaptchaToken"];
        }
    }

    static fromJS(data: any): AppRegister {
        data = typeof data === 'object' ? data : {};
        let result = new AppRegister();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["appId"] = this.appId;
        data["appKey"] = this.appKey;
        data["recaptchaToken"] = this.recaptchaToken;
        return data;
    }
}

export interface IAppRegister {
    appId: string;
    appKey: string;
    recaptchaToken: string;

    [key: string]: any;
}

export class BasicResponse implements IBasicResponse {
    code!: number;
    message!: string;

    [key: string]: any;

    constructor(data?: IBasicResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): BasicResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BasicResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data;
    }
}

export interface IBasicResponse {
    code: number;
    message: string;

    [key: string]: any;
}

export class BodyCheck implements IBodyCheck {
    itemString!: string;
    itemInt!: number;
    itemList!: any[];

    [key: string]: any;

    constructor(data?: IBodyCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.itemList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.itemString = _data["itemString"];
            this.itemInt = _data["itemInt"];
            if (Array.isArray(_data["itemList"])) {
                this.itemList = [] as any;
                for (let item of _data["itemList"])
                    this.itemList!.push(item);
            }
        }
    }

    static fromJS(data: any): BodyCheck {
        data = typeof data === 'object' ? data : {};
        let result = new BodyCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["itemString"] = this.itemString;
        data["itemInt"] = this.itemInt;
        if (Array.isArray(this.itemList)) {
            data["itemList"] = [];
            for (let item of this.itemList)
                data["itemList"].push(item);
        }
        return data;
    }
}

export interface IBodyCheck {
    itemString: string;
    itemInt: number;
    itemList: any[];

    [key: string]: any;
}

export class Body_bearer_token_access_token_post implements IBody_bearer_token_access_token_post {
    grant_type!: string;
    username!: string;
    password!: string;
    scope!: string;
    client_id!: string;
    client_secret!: string;

    [key: string]: any;

    constructor(data?: IBody_bearer_token_access_token_post) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scope = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.grant_type = _data["grant_type"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.scope = _data["scope"] !== undefined ? _data["scope"] : "";
            this.client_id = _data["client_id"];
            this.client_secret = _data["client_secret"];
        }
    }

    static fromJS(data: any): Body_bearer_token_access_token_post {
        data = typeof data === 'object' ? data : {};
        let result = new Body_bearer_token_access_token_post();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["grant_type"] = this.grant_type;
        data["username"] = this.username;
        data["password"] = this.password;
        data["scope"] = this.scope;
        data["client_id"] = this.client_id;
        data["client_secret"] = this.client_secret;
        return data;
    }
}

export interface IBody_bearer_token_access_token_post {
    grant_type: string;
    username: string;
    password: string;
    scope: string;
    client_id: string;
    client_secret: string;

    [key: string]: any;
}

export class Body_bulk_register_admin_bulk_register_post implements IBody_bulk_register_admin_bulk_register_post {
    file!: string;

    [key: string]: any;

    constructor(data?: IBody_bulk_register_admin_bulk_register_post) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body_bulk_register_admin_bulk_register_post {
        data = typeof data === 'object' ? data : {};
        let result = new Body_bulk_register_admin_bulk_register_post();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

export interface IBody_bulk_register_admin_bulk_register_post {
    file: string;

    [key: string]: any;
}

export class Body_route_login_access_token_token_cookie_post implements IBody_route_login_access_token_token_cookie_post {
    grant_type!: string;
    username!: string;
    password!: string;
    scope!: string;
    client_id!: string;
    client_secret!: string;

    [key: string]: any;

    constructor(data?: IBody_route_login_access_token_token_cookie_post) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scope = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.grant_type = _data["grant_type"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.scope = _data["scope"] !== undefined ? _data["scope"] : "";
            this.client_id = _data["client_id"];
            this.client_secret = _data["client_secret"];
        }
    }

    static fromJS(data: any): Body_route_login_access_token_token_cookie_post {
        data = typeof data === 'object' ? data : {};
        let result = new Body_route_login_access_token_token_cookie_post();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["grant_type"] = this.grant_type;
        data["username"] = this.username;
        data["password"] = this.password;
        data["scope"] = this.scope;
        data["client_id"] = this.client_id;
        data["client_secret"] = this.client_secret;
        return data;
    }
}

export interface IBody_route_login_access_token_token_cookie_post {
    grant_type: string;
    username: string;
    password: string;
    scope: string;
    client_id: string;
    client_secret: string;

    [key: string]: any;
}

export class BulkUserInsertionResponse implements IBulkUserInsertionResponse {
    code!: number;
    message!: string;
    succesfulInsertions!: UserDetails[];
    failedInsertions!: FailedInsertionUserDetails[];

    [key: string]: any;

    constructor(data?: IBulkUserInsertionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.succesfulInsertions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["succesfulInsertions"])) {
                this.succesfulInsertions = [] as any;
                for (let item of _data["succesfulInsertions"])
                    this.succesfulInsertions!.push(UserDetails.fromJS(item));
            }
            if (Array.isArray(_data["failedInsertions"])) {
                this.failedInsertions = [] as any;
                for (let item of _data["failedInsertions"])
                    this.failedInsertions!.push(FailedInsertionUserDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkUserInsertionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUserInsertionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.succesfulInsertions)) {
            data["succesfulInsertions"] = [];
            for (let item of this.succesfulInsertions)
                data["succesfulInsertions"].push(item.toJSON());
        }
        if (Array.isArray(this.failedInsertions)) {
            data["failedInsertions"] = [];
            for (let item of this.failedInsertions)
                data["failedInsertions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBulkUserInsertionResponse {
    code: number;
    message: string;
    succesfulInsertions: UserDetails[];
    failedInsertions: FailedInsertionUserDetails[];

    [key: string]: any;
}

export class CreateCode implements ICreateCode {
    email!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICreateCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateCode {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateCode {
    email: string;
    type: string;

    [key: string]: any;
}

export class FailedInsertionUserDetails implements IFailedInsertionUserDetails {
    title!: string;
    firstName!: string;
    lastName!: string;
    mobile!: string;
    email!: string;
    createdAt!: number;
    updatedAt!: number;
    organizationId!: string;
    permissions!: any;

    [key: string]: any;

    constructor(data?: IFailedInsertionUserDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.title = "";
            this.firstName = "";
            this.lastName = "";
            this.mobile = "";
            this.email = "";
            this.createdAt = 0;
            this.updatedAt = 0;
            this.organizationId = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"] !== undefined ? _data["title"] : "";
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : "";
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : "";
            this.mobile = _data["mobile"] !== undefined ? _data["mobile"] : "";
            this.email = _data["email"] !== undefined ? _data["email"] : "";
            this.createdAt = _data["createdAt"] !== undefined ? _data["createdAt"] : 0;
            this.updatedAt = _data["updatedAt"] !== undefined ? _data["updatedAt"] : 0;
            this.organizationId = _data["organizationId"] !== undefined ? _data["organizationId"] : "";
            this.permissions = _data["permissions"];
        }
    }

    static fromJS(data: any): FailedInsertionUserDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FailedInsertionUserDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        data["organizationId"] = this.organizationId;
        data["permissions"] = this.permissions;
        return data;
    }
}

export interface IFailedInsertionUserDetails {
    title: string;
    firstName: string;
    lastName: string;
    mobile: string;
    email: string;
    createdAt: number;
    updatedAt: number;
    organizationId: string;
    permissions: any;

    [key: string]: any;
}

export class HTTPValidationError implements IHTTPValidationError {
    detail!: ValidationError[];

    [key: string]: any;

    constructor(data?: IHTTPValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["detail"])) {
                this.detail = [] as any;
                for (let item of _data["detail"])
                    this.detail!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HTTPValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new HTTPValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.detail)) {
            data["detail"] = [];
            for (let item of this.detail)
                data["detail"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHTTPValidationError {
    detail: ValidationError[];

    [key: string]: any;
}

export class Login implements ILogin {
    email!: string;
    password!: string;
    otp!: string;

    [key: string]: any;

    constructor(data?: ILogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.otp = _data["otp"];
        }
    }

    static fromJS(data: any): Login {
        data = typeof data === 'object' ? data : {};
        let result = new Login();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["otp"] = this.otp;
        return data;
    }
}

export interface ILogin {
    email: string;
    password: string;
    otp: string;

    [key: string]: any;
}

export class LoginResponse implements ILoginResponse {
    code!: number;
    access_token!: string;
    token_type!: string;
    username!: string;
    entityId!: string;

    [key: string]: any;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.code = 200;
            this.access_token = "";
            this.token_type = "";
            this.username = "";
            this.entityId = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"] !== undefined ? _data["code"] : 200;
            this.access_token = _data["access_token"] !== undefined ? _data["access_token"] : "";
            this.token_type = _data["token_type"] !== undefined ? _data["token_type"] : "";
            this.username = _data["username"] !== undefined ? _data["username"] : "";
            this.entityId = _data["entityId"] !== undefined ? _data["entityId"] : "";
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["access_token"] = this.access_token;
        data["token_type"] = this.token_type;
        data["username"] = this.username;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface ILoginResponse {
    code: number;
    access_token: string;
    token_type: string;
    username: string;
    entityId: string;

    [key: string]: any;
}

export class NewQuote implements INewQuote {
    quoteId!: string;
    firstName!: string;
    lastName!: string;
    mobile!: string;
    email!: string;

    [key: string]: any;

    constructor(data?: INewQuote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.quoteId = _data["quoteId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): NewQuote {
        data = typeof data === 'object' ? data : {};
        let result = new NewQuote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["quoteId"] = this.quoteId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        return data;
    }
}

export interface INewQuote {
    quoteId: string;
    firstName: string;
    lastName: string;
    mobile: string;
    email: string;

    [key: string]: any;
}

export class Permissions implements IPermissions {
    name!: string;
    description!: string;
    active!: boolean;

    [key: string]: any;

    constructor(data?: IPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): Permissions {
        data = typeof data === 'object' ? data : {};
        let result = new Permissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["active"] = this.active;
        return data;
    }
}

export interface IPermissions {
    name: string;
    description: string;
    active: boolean;

    [key: string]: any;
}

export class PermissionsResponse implements IPermissionsResponse {
    code!: number;
    permissions!: Permissions[];

    [key: string]: any;

    constructor(data?: IPermissionsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permissions.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionsResponse {
    code: number;
    permissions: Permissions[];

    [key: string]: any;
}

export class QRUserDataResponse implements IQRUserDataResponse {
    code!: number;
    details!: QuoteDetails;

    [key: string]: any;

    constructor(data?: IQRUserDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.details = new QuoteDetails();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.details = _data["details"] ? QuoteDetails.fromJS(_data["details"]) : new QuoteDetails();
        }
    }

    static fromJS(data: any): QRUserDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QRUserDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        return data;
    }
}

export interface IQRUserDataResponse {
    code: number;
    details: QuoteDetails;

    [key: string]: any;
}

export class QuoteDetails implements IQuoteDetails {
    quoteId!: string;
    uuid!: string;
    firstName!: string;
    lastName!: string;
    agentId!: string;
    email!: string;
    mobile!: string;
    createdAt!: number;
    verifiedAt!: number;
    active!: boolean;

    [key: string]: any;

    constructor(data?: IQuoteDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.quoteId = _data["quoteId"];
            this.uuid = _data["uuid"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.agentId = _data["agentId"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.createdAt = _data["createdAt"];
            this.verifiedAt = _data["verifiedAt"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): QuoteDetails {
        data = typeof data === 'object' ? data : {};
        let result = new QuoteDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["quoteId"] = this.quoteId;
        data["uuid"] = this.uuid;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["agentId"] = this.agentId;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["createdAt"] = this.createdAt;
        data["verifiedAt"] = this.verifiedAt;
        data["active"] = this.active;
        return data;
    }
}

export interface IQuoteDetails {
    quoteId: string;
    uuid: string;
    firstName: string;
    lastName: string;
    agentId: string;
    email: string;
    mobile: string;
    createdAt: number;
    verifiedAt: number;
    active: boolean;

    [key: string]: any;
}

export class RegisterUser implements IRegisterUser {
    title!: string;
    firstName!: string;
    lastName!: string;
    mobile!: string;
    email!: string;
    userType!: string;
    permissions!: any;

    [key: string]: any;

    constructor(data?: IRegisterUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.userType = _data["userType"];
            this.permissions = _data["permissions"];
        }
    }

    static fromJS(data: any): RegisterUser {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["userType"] = this.userType;
        data["permissions"] = this.permissions;
        return data;
    }
}

export interface IRegisterUser {
    title: string;
    firstName: string;
    lastName: string;
    mobile: string;
    email: string;
    userType: string;
    permissions: any;

    [key: string]: any;
}

export class SMSSuccessBody implements ISMSSuccessBody {
    eventId!: number;
    msisdn!: string;
    status!: string;
    received!: number;
    userReference!: string;
    mnc!: string;
    mcc!: number;
    msgCount!: number;

    [key: string]: any;

    constructor(data?: ISMSSuccessBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.eventId = _data["EventId"];
            this.msisdn = _data["Msisdn"];
            this.status = _data["Status"];
            this.received = _data["Received"];
            this.userReference = _data["UserReference"];
            this.mnc = _data["Mnc"];
            this.mcc = _data["Mcc"];
            this.msgCount = _data["MsgCount"];
        }
    }

    static fromJS(data: any): SMSSuccessBody {
        data = typeof data === 'object' ? data : {};
        let result = new SMSSuccessBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["EventId"] = this.eventId;
        data["Msisdn"] = this.msisdn;
        data["Status"] = this.status;
        data["Received"] = this.received;
        data["UserReference"] = this.userReference;
        data["Mnc"] = this.mnc;
        data["Mcc"] = this.mcc;
        data["MsgCount"] = this.msgCount;
        return data;
    }
}

export interface ISMSSuccessBody {
    eventId: number;
    msisdn: string;
    status: string;
    received: number;
    userReference: string;
    mnc: string;
    mcc: number;
    msgCount: number;

    [key: string]: any;
}

export class SMSSuccessResponse implements ISMSSuccessResponse {
    code!: number;
    status!: string;
    userReference!: string;
    eventId!: number;

    [key: string]: any;

    constructor(data?: ISMSSuccessResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.status = _data["status"];
            this.userReference = _data["userReference"];
            this.eventId = _data["eventId"];
        }
    }

    static fromJS(data: any): SMSSuccessResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SMSSuccessResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["status"] = this.status;
        data["userReference"] = this.userReference;
        data["eventId"] = this.eventId;
        return data;
    }
}

export interface ISMSSuccessResponse {
    code: number;
    status: string;
    userReference: string;
    eventId: number;

    [key: string]: any;
}

export class StatusCheck implements IStatusCheck {
    status!: string;

    [key: string]: any;

    constructor(data?: IStatusCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): StatusCheck {
        data = typeof data === 'object' ? data : {};
        let result = new StatusCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        return data;
    }
}

export interface IStatusCheck {
    status: string;

    [key: string]: any;
}

export class TokenDetails implements ITokenDetails {
    sub!: string;
    exp!: number;
    userId!: string;
    entityId!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ITokenDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sub = "";
            this.exp = 0;
            this.userId = "";
            this.entityId = "";
            this.type = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sub = _data["sub"] !== undefined ? _data["sub"] : "";
            this.exp = _data["exp"] !== undefined ? _data["exp"] : 0;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : "";
            this.entityId = _data["entityId"] !== undefined ? _data["entityId"] : "";
            this.type = _data["type"] !== undefined ? _data["type"] : "";
        }
    }

    static fromJS(data: any): TokenDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sub"] = this.sub;
        data["exp"] = this.exp;
        data["userId"] = this.userId;
        data["entityId"] = this.entityId;
        data["type"] = this.type;
        return data;
    }
}

export interface ITokenDetails {
    sub: string;
    exp: number;
    userId: string;
    entityId: string;
    type: string;

    [key: string]: any;
}

export class TokenResponse implements ITokenResponse {
    code!: number;
    token!: TokenDetails;

    [key: string]: any;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.token = new TokenDetails();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.token = _data["token"] ? TokenDetails.fromJS(_data["token"]) : new TokenDetails();
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["token"] = this.token ? this.token.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITokenResponse {
    code: number;
    token: TokenDetails;

    [key: string]: any;
}

export class UserDetails implements IUserDetails {
    _id!: string;
    title!: string;
    firstName!: string;
    lastName!: string;
    mobile!: string;
    email!: string;
    createdAt!: number;
    updatedAt!: number;
    organizationId!: string;
    permissions!: any;

    [key: string]: any;

    constructor(data?: IUserDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.title = "";
            this.firstName = "";
            this.lastName = "";
            this.mobile = "";
            this.email = "";
            this.createdAt = 0;
            this.updatedAt = 0;
            this.organizationId = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this._id = _data["_id"];
            this.title = _data["title"] !== undefined ? _data["title"] : "";
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : "";
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : "";
            this.mobile = _data["mobile"] !== undefined ? _data["mobile"] : "";
            this.email = _data["email"] !== undefined ? _data["email"] : "";
            this.createdAt = _data["createdAt"] !== undefined ? _data["createdAt"] : 0;
            this.updatedAt = _data["updatedAt"] !== undefined ? _data["updatedAt"] : 0;
            this.organizationId = _data["organizationId"] !== undefined ? _data["organizationId"] : "";
            this.permissions = _data["permissions"];
        }
    }

    static fromJS(data: any): UserDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["_id"] = this._id;
        data["title"] = this.title;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        data["organizationId"] = this.organizationId;
        data["permissions"] = this.permissions;
        return data;
    }
}

export interface IUserDetails {
    _id: string;
    title: string;
    firstName: string;
    lastName: string;
    mobile: string;
    email: string;
    createdAt: number;
    updatedAt: number;
    organizationId: string;
    permissions: any;

    [key: string]: any;
}

export class UserDetailsManyResponse implements IUserDetailsManyResponse {
    code!: number;
    users!: UserDetails[];

    [key: string]: any;

    constructor(data?: IUserDetailsManyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.users = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDetailsManyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailsManyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDetailsManyResponse {
    code: number;
    users: UserDetails[];

    [key: string]: any;
}

export class UserDetailsResponse implements IUserDetailsResponse {
    code!: number;
    details!: UserDetails;

    [key: string]: any;

    constructor(data?: IUserDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.details = _data["details"] ? UserDetails.fromJS(_data["details"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserDetailsResponse {
    code: number;
    details: UserDetails;

    [key: string]: any;
}

export class ValidationError implements IValidationError {
    loc!: Loc[];
    msg!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: IValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.loc = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["loc"])) {
                this.loc = [] as any;
                for (let item of _data["loc"])
                    this.loc!.push(item);
            }
            this.msg = _data["msg"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.loc)) {
            data["loc"] = [];
            for (let item of this.loc)
                data["loc"].push(item);
        }
        data["msg"] = this.msg;
        data["type"] = this.type;
        return data;
    }
}

export interface IValidationError {
    loc: Loc[];
    msg: string;
    type: string;

    [key: string]: any;
}

export class VerifyResponse implements IVerifyResponse {
    code!: number;
    type!: string;

    [key: string]: any;

    constructor(data?: IVerifyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): VerifyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["type"] = this.type;
        return data;
    }
}

export interface IVerifyResponse {
    code: number;
    type: string;

    [key: string]: any;
}

export class Loc implements ILoc {

    [key: string]: any;

    constructor(data?: ILoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Loc {
        data = typeof data === 'object' ? data : {};
        let result = new Loc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ILoc {

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}